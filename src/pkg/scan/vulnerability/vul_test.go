package vulnerability

import (
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"

	"github.com/goharbor/harbor/src/common/rbac"
	"github.com/goharbor/harbor/src/pkg/permission/types"
	"github.com/goharbor/harbor/src/pkg/robot/model"
	"github.com/goharbor/harbor/src/pkg/scan/dao/scan"
	"github.com/goharbor/harbor/src/pkg/scan/postprocessors"
	v1 "github.com/goharbor/harbor/src/pkg/scan/rest/v1"
	"github.com/goharbor/harbor/src/testing/jobservice"
	postprocessorstesting "github.com/goharbor/harbor/src/testing/pkg/scan/postprocessors"
)

func TestRequiredPermissions(t *testing.T) {
	v := &ScanHandler{}
	expected := []*types.Policy{
		{
			Resource: rbac.ResourceRepository,
			Action:   rbac.ActionPull,
		},
		{
			Resource: rbac.ResourceRepository,
			Action:   rbac.ActionScannerPull,
		},
	}

	result := v.RequiredPermissions()

	assert.Equal(t, expected, result, "RequiredPermissions should return correct permissions")
}

func TestPostScan(t *testing.T) {
	v := &ScanHandler{}
	ctx := &jobservice.MockJobContext{}
	artifact := &v1.Artifact{}
	origRp := &scan.Report{}
	rawReport := ""

	mocker := &postprocessorstesting.ScanReportV1ToV2Converter{}
	mocker.On("ToRelationalSchema", mock.Anything, mock.Anything, mock.Anything, mock.Anything, mock.Anything).Return(nil, "original report", nil)
	postprocessors.Converter = mocker
	sr := &v1.ScanRequest{Artifact: artifact}
	refreshedReport, err := v.PostScan(ctx, sr, origRp, rawReport, time.Now(), &model.Robot{})
	assert.Equal(t, "", refreshedReport, "PostScan should return the refreshed report")
	assert.Nil(t, err, "PostScan should not return an error")
}

func TestScanHandler_RequiredPermissions(t *testing.T) {
	tests := []struct {
		name string
		want []*types.Policy
	}{
		{"normal", []*types.Policy{
			{
				Resource: rbac.ResourceRepository,
				Action:   rbac.ActionPull,
			},
			{
				Resource: rbac.ResourceRepository,
				Action:   rbac.ActionScannerPull,
			},
		}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &ScanHandler{}
			assert.Equalf(t, tt.want, v.RequiredPermissions(), "RequiredPermissions()")
		})
	}
}

func TestScanHandler_ReportURLParameter(t *testing.T) {
	type args struct {
		in0 *v1.ScanRequest
	}
	tests := []struct {
		name    string
		args    args
		want    string
		wantErr assert.ErrorAssertionFunc
	}{
		{"normal", args{&v1.ScanRequest{}}, "", assert.NoError},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &ScanHandler{}
			got, err := v.ReportURLParameter(tt.args.in0)
			if !tt.wantErr(t, err, fmt.Sprintf("ReportURLParameter(%v)", tt.args.in0)) {
				return
			}
			assert.Equalf(t, tt.want, got, "ReportURLParameter(%v)", tt.args.in0)
		})
	}
}

func TestScanHandler_RequestProducesMineTypes(t *testing.T) {
	tests := []struct {
		name string
		want []string
	}{
		{"normal", []string{v1.MimeTypeGenericVulnerabilityReport}},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			v := &ScanHandler{}
			assert.Equalf(t, tt.want, v.RequestProducesMineTypes(), "RequestProducesMineTypes()")
		})
	}
}
